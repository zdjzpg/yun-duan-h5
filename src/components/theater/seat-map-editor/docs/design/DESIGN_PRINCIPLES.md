# 🎯 座位图编辑器 - 设计原则与开发思考方式

**创建时间：** 2025-12-17  
**目的：** 记录核心设计理念和思维误区，避免重复犯错

---

## 📖 核心设计理念

### 1️⃣ "观众视角"统一规则

**理念：**
- 所有楼层、所有座区、所有视图都统一使用"观众视角"
- 观众面向舞台，左手边是1号座，右手边是最大号座
- 不存在"管理员视角"、"舞台视角"等其他视角

**为什么重要：**
- 避免视角混乱，导致选座时左右颠倒
- 确保数据一致性，无需视角转换逻辑
- 符合观众的真实购票体验

**检查点：**
- [ ] 所有座位编号逻辑是否基于"观众视角"？
- [ ] Canvas 渲染是否符合"观众面向舞台"的方向？
- [ ] 导出的座位图是否符合观众的实际视角？

---

### 2️⃣ "座区是标签，不是容器"⭐ 核心教训

**理念：**
```
❌ 错误理解：座区 = 容器，座位 = 内容
✅ 正确理解：座位 = 坐标点，座区 = 标签
```

**具体含义：**
- 座位是物理位置的坐标点（x, y），是客观存在
- 座区是业务属性的标签（VIP区、普通区），是主观分类
- 座位先存在，座区后添加（不能先有座区，再装座位）

**正确的创建流程：**
```
步骤 1：在 Canvas 上绘制座位（确定物理位置）
   ↓
步骤 2：选择一组座位
   ↓
步骤 3：右键 → 创建座区（给这组座位贴上"VIP区"标签）
   ↓
结果：座位已有座区属性，不存在"空座区"
```

**错误的创建流程（传统 SaaS 思维）：**
```
步骤 1：创建一个空座区"VIP区" ❌
   ↓
步骤 2：选择座位
   ↓
步骤 3：分配座位到"VIP区"
   ↓
问题：在步骤 1-2 之间，存在"空座区"（违背业务逻辑）
```

**为什么会犯错：**
- **传统 SaaS 思维惯性：** 大多数管理系统都是"先建配置，再关联数据"
  - 先创建商品分类 → 再添加商品
  - 先创建部门 → 再分配员工
  - 这种模式太常见，很容易套用
- **阶段性开发的路径依赖：** 实现数据模型后，自然而然地实现了 CRUD 操作
- **没有及时回顾 PRD：** 忽略了产品文档中的核心理念

**如何避免：**
- ✅ 在设计 API 之前，先问："这个实体是什么？容器还是标签？"
- ✅ 在实现功能时，反复检查："会不会创建出空的、无意义的数据？"
- ✅ 对比真实世界："剧场管理员会先创建一个空的VIP区吗？"

**检查点：**
- [ ] 是否允许创建"空座区"？（应该禁止）
- [ ] 创建座区的入口是否基于"已选中的座位"？
- [ ] 座区删除后，座位是否还存在？（应该存在，只是失去标签）

---

### 3️⃣ "座位、座区、通道"的三元关系

**理念：**
```
座位 = 坐标点（需要绘制）
座区 = 标签（选座位创建）
通道 = 空白区域（不需要绘制）
```

**具体含义：**
- **座位：** 在 Canvas 上绘制的圆形，有明确的 (x, y) 坐标
- **座区：** 一组座位的业务属性（名称、颜色、价格等）
- **通道：** 座位之间的间隙，不需要额外绘制，自然形成

**为什么重要：**
- 避免过度设计：不要为"通道"创建数据模型
- 简化编辑器：只需要绘制座位和舞台，通道自动形成
- 符合真实剧场：通道就是"没有座位的地方"

**检查点：**
- [ ] 是否为"通道"创建了数据模型？（不应该）
- [ ] 是否需要手动绘制通道？（不需要）
- [ ] 通道宽度是否通过座位间距自然形成？（应该是）

---

## 🚨 常见思维误区

### 误区 1：套用传统 SaaS 的"配置-数据"模式

**表现：**
- 总是想"先建配置，再关联数据"
- 允许创建"空的配置"（空座区、空楼层等）

**正确做法：**
- 问自己："这个实体在真实世界中会单独存在吗？"
- 如果答案是"不会"，那就不应该支持单独创建

**例子：**
- ❌ 空座区（没有座位的VIP区）→ 真实世界中不存在
- ✅ 空楼层（没有座位的楼层）→ 真实世界中存在（新建剧场时）

---

### 误区 2：忽略业务场景，只关注技术实现

**表现：**
- 看到 Zone 类型，就实现 createZone、updateZone、deleteZone
- 没有思考："用户在什么场景下创建座区？"

**正确做法：**
- 先设计用户故事：
  ```
  作为剧场管理员
  我想将前3排座位标记为"VIP区"
  以便设置更高的票价
  ```
- 再设计交互流程：
  ```
  1. 选择前3排座位
  2. 右键 → 创建座区
  3. 填写名称"VIP区"
  4. 确定
  ```
- 最后实现技术方案

**检查点：**
- [ ] 是否先设计了用户故事？
- [ ] 是否验证了交互流程的合理性？
- [ ] 是否对比了真实世界的操作方式？

---

### 误区 3：阶段性开发导致的"路径依赖"

**表现：**
- 阶段 1 实现了错误的逻辑
- 阶段 2-3 在错误的基础上"打补丁"
- 阶段 4 才发现需要推倒重来

**正确做法：**
- 在每个阶段结束后，回顾 PRD
- 问自己："这个实现符合产品理念吗？"
- 如果发现偏差，立即重构，而不是"先完成再说"

**检查点：**
- [ ] 每个阶段完成后，是否回顾了 PRD？
- [ ] 是否存在"先实现再重构"的侥幸心理？
- [ ] 是否记录了设计决策的原因？

---

## ✅ 正确的思考方式

### 开发前三问：

#### 1️⃣ "这是什么？"（本质）

**问：** 我要实现的这个实体，在真实世界中是什么？

**例子：**
- 座区 → 真实剧场中，座区是一组座位的分类标签
- 楼层 → 真实剧场中，楼层是物理空间的层级
- 座位 → 真实剧场中，座位是有固定坐标的位置

**检查：**
- [ ] 我理解了这个实体的真实含义吗？
- [ ] 我的理解和 PRD 一致吗？

---

#### 2️⃣ "怎么用？"（场景）

**问：** 用户在什么场景下使用这个功能？

**例子：**
- 创建座区 → 用户已经绘制了座位，想给一组座位设置价格
- 批量生成座位 → 用户想快速创建规则排列的座位
- 重新编号 → 用户调整了座位位置，想重新分配编号

**检查：**
- [ ] 我设计的交互流程符合真实场景吗？
- [ ] 用户能在最少的步骤内完成任务吗？

---

#### 3️⃣ "会出错吗？"（边界）

**问：** 这个设计会导致什么异常状态？

**例子：**
- 创建空座区 → ❌ 允许，会导致"没有座位的VIP区"
- 删除楼层 → ✅ 提示用户会删除该楼层的所有座位
- 座区重名 → ✅ 在同一楼层内禁止重名

**检查：**
- [ ] 是否允许创建"无意义的数据"？
- [ ] 删除操作是否会导致数据孤岛？
- [ ] 是否处理了所有边界情况？

---

## 📋 开发检查清单

### 设计阶段：

- [ ] **回顾 PRD：** 这个功能的产品理念是什么？
- [ ] **真实世界对比：** 剧场管理员在真实世界中如何操作？
- [ ] **用户故事：** 用户在什么场景下使用这个功能？
- [ ] **交互流程：** 用户需要几个步骤完成任务？
- [ ] **边界情况：** 会不会创建"无意义的数据"？

### 实现阶段：

- [ ] **本质理解：** 这个实体是"容器"还是"标签"？
- [ ] **依赖关系：** 这个实体依赖哪些其他实体？
- [ ] **生命周期：** 这个实体何时创建、更新、删除？
- [ ] **数据一致性：** 删除时如何处理关联数据？
- [ ] **错误处理：** 是否处理了所有异常情况？

### 测试阶段：

- [ ] **正常流程：** 用户按照设计的流程操作，是否正常？
- [ ] **异常流程：** 用户进行非预期操作，是否有提示？
- [ ] **边界测试：** 空数据、大量数据、极端情况是否正常？
- [ ] **回归测试：** 新功能是否影响了旧功能？
- [ ] **真实场景：** 在真实的业务场景下，是否符合预期？

---

## 🎓 案例复盘：座区创建流程重构

### 问题发现：

**时间：** 阶段 6.4  
**问题：** 实现了"先创建空座区，再分配座位"的错误流程  
**表现：** 允许创建没有座位的"VIP区"

### 根本原因：

1. **传统 SaaS 思维惯性：** 套用了"先建配置，再关联数据"的模式
2. **阶段性开发路径依赖：** 实现了 Zone 类型后，自然实现了 createZone
3. **没有及时回顾 PRD：** 忽略了"座区是标签（选座位创建）"的核心理念

### 解决方案：

**废弃：**
```typescript
// ❌ 废弃：创建空座区
const handleCreateZone = (zone: Omit<Zone, 'id'>) => {
  const newZone: Zone = { ...zone, id: generateId('zone') };
  setZones([...zones, newZone]);
};
```

**新增：**
```typescript
// ✅ 正确：基于选中座位创建座区
const handleCreateZoneFromSeats = () => {
  if (selectedSeatIds.length === 0) {
    message.warning('请先选择座位');
    return;
  }
  setZoneConfigModalVisible(true);
};
```

### 经验教训：

1. **在设计阶段就要问"三问"：** 这是什么？怎么用？会出错吗？
2. **每个阶段完成后回顾 PRD：** 避免路径依赖
3. **对比真实世界：** 剧场管理员不会先创建空座区
4. **优先实现核心流程：** 而不是"先把 CRUD 做完"

### 重构成果：

- ✅ 用户选择座位 → 创建座区（一步到位）
- ✅ 不会创建空座区
- ✅ 符合"座区是标签"的产品理念
- ✅ 交互流程从 8 步减少到 4 步

---

## 🔄 持续改进

### 定期回顾：

- **每个阶段结束：** 检查是否符合设计原则
- **每个功能完成：** 对照检查清单验证
- **发现问题时：** 更新此文档，记录新的教训

### 文档更新：

**如果发现新的思维误区：**
1. 在"常见思维误区"章节添加案例
2. 更新"开发检查清单"
3. 提炼通用的设计原则

**如果发现更好的思考方式：**
1. 在"正确的思考方式"章节补充
2. 用具体案例说明
3. 提供可操作的检查点

---

## 📚 延伸阅读

### 相关文档：

- **产品 PRD：** 座位图编辑器的核心理念和业务规则
- **阶段规划：** 功能迭代的优先级和依赖关系
- **重构总结：** 阶段 6.4 座区创建流程重构详细记录

### 推荐思考框架：

1. **领域驱动设计（DDD）：** 理解业务实体的本质
2. **用户故事驱动：** 从用户场景出发设计功能
3. **最小可行产品（MVP）：** 优先实现核心流程

---

## 🎯 总结

**核心原则：**
1. **观众视角：** 统一使用观众面向舞台的视角
2. **座区是标签：** 不是容器，不能单独创建
3. **通道是空白：** 不需要绘制，自然形成

**思考方式：**
1. **开发前三问：** 这是什么？怎么用？会出错吗？
2. **对比真实世界：** 剧场管理员如何操作？
3. **回顾 PRD：** 是否符合产品理念？

**检查清单：**
- 设计阶段：用户故事、交互流程、边界情况
- 实现阶段：本质理解、依赖关系、数据一致性
- 测试阶段：正常流程、异常流程、真实场景

---

**最后提醒：**

> "座区是标签，不是容器"  
> 这不仅是技术实现，更是业务理念  
> 在每次开发前，先问自己：  
> **"这符合真实世界的逻辑吗？"**

---

**文档状态：** ✅ 活跃维护  
**最后更新：** 2025-12-17  
**维护责任：** 开发团队全体成员
